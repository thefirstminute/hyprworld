#!/usr/bin/env python3
import json
import subprocess
import sys
import math

# --- Helper Functions for Hyprland Data ---

def get_hyprland_data(command):
    """Fetches and decodes JSON data from hyprctl."""
    try:
        result = subprocess.run(
            f"hyprctl {command} -j", 
            shell=True, 
            check=True, 
            stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE,
            text=True
        )
        
        json_output = result.stdout.strip()

        # Handle Hyprland non-JSON prefix like "ok" or "ok\n" which causes parsing errors.
        if json_output.lower().startswith('ok\n'):
            json_output = json_output[3:].lstrip()
        elif json_output.lower().startswith('ok'):
            json_output = json_output[2:].lstrip()

        if not json_output:
             return None
        return json.loads(json_output)
    except Exception as e:
        # Note: If this fails, it often means the hyprctl command itself is broken or returned
        # completely non-JSON data that wasn't just 'ok'.
        print(f"Error fetching data from hyprctl {command}: {e}", file=sys.stderr)
        return None

# --- Geometry Functions ---

def get_center(window):
    """Calculates the center coordinates of a window."""
    x = window.get('at', [0, 0])[0]
    y = window.get('at', [0, 0])[1]
    w = window.get('size', [0, 0])[0]
    h = window.get('size', [0, 0])[1]
    return x + w / 2, y + h / 2

def calculate_distance(p1, p2):
    """Calculates the Euclidean distance between two points."""
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

# --- Main Logic ---

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 hypr_smart_focus.py <direction: l, r, u, d>")
        sys.exit(1)

    direction = sys.argv[1].lower()
    
    # Fetch all necessary data
    active_window = get_hyprland_data("activewindow")
    clients = get_hyprland_data("clients")

    if not active_window or not clients:
        print("Failed to retrieve necessary Hyprland data.", file=sys.stderr)
        sys.exit(1)

    # Filter candidates:
    # 1. Must be mapped (visible).
    # 2. Must NOT be hidden. (This inherently excludes windows on inactive workspaces)
    # 3. Must NOT be the active window itself.
    candidates = []
    for c in clients:
        # Check 1 & 2: Use Hyprland's visibility flags directly
        if not c.get('mapped') or c.get('hidden'):
            continue
            
        # Check 3: Must not be the active window
        if c.get('address') == active_window.get('address'):
            continue
            
        candidates.append(c)

    active_cx, active_cy = get_center(active_window)
    
    best_candidate = None
    min_distance_score = float('inf')
    
    for client in candidates:
        cx, cy = get_center(client)
        dx = cx - active_cx
        dy = cy - active_cy
        
        is_in_direction = False
        dist_score = float('inf')

        # Hyper-Weighted Distance Logic: Prioritize primary axis distance, use secondary for tie-breaking.
        if direction == 'l': # Left: x decreases (dx < 0)
            if dx < 0:
                is_in_direction = True
                # Minimize abs(dx). Use abs(dy) as minimal tie-breaker.
                dist_score = abs(dx) + abs(dy) / 10000.0
        elif direction == 'r': # Right: x increases (dx > 0)
            if dx > 0:
                is_in_direction = True
                # Minimize abs(dx). Use abs(dy) as minimal tie-breaker.
                dist_score = abs(dx) + abs(dy) / 10000.0
        elif direction == 'u': # Up: y decreases (dy < 0)
            if dy < 0:
                is_in_direction = True
                # Minimize abs(dy). Use abs(dx) as minimal tie-breaker.
                dist_score = abs(dy) + abs(dx) / 10000.0
        elif direction == 'd': # Down: y increases (dy > 0)
            if dy > 0:
                is_in_direction = True
                # Minimize abs(dy). Use abs(dx) as minimal tie-breaker.
                dist_score = abs(dy) + abs(dx) / 10000.0

        if is_in_direction:
            if dist_score < min_distance_score:
                min_distance_score = dist_score
                best_candidate = client

    if best_candidate:
        addr = best_candidate.get('address')
        print(f"Focusing window: {best_candidate.get('title')} ({addr})")
        
        # 1. Switch to the window's workspace
        target_ws_id = best_candidate.get('workspace', {}).get('id')
        if target_ws_id is not None:
             subprocess.run(f"hyprctl dispatch workspace {target_ws_id}", shell=True)

        # 2. Focus the window
        subprocess.run(f"hyprctl dispatch focuswindow address:{addr}", shell=True)
        
        # 3. If it's floating, raise it to top (Z-order)
        if best_candidate.get('floating'):
            subprocess.run("hyprctl dispatch alterzorder top", shell=True)
            
    else:
        # Fallback to native movefocus 
        print("No smart candidate found. Fallback to native movefocus.")
        subprocess.run(f"hyprctl dispatch movefocus {direction}", shell=True)

if __name__ == "__main__":
    main()
