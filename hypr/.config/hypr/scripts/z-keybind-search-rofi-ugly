#!/usr/bin/env bash

# --- CONFIGURATION ---
PAD=20
# Rofi uses .rasi for themes, NOT .css
STYLE="${HOME}/.config/rofi/search.rasi"
KEYDIR="${HOME}/.config/hypr/keys"
VARS="${HOME}/.config/hypr/vars.conf"

# 1. Separator & Spacer (still useful for keeping hidden ID/tokens separate)
INVISIBLE_SEP=$'\u200b'
SPACER="$(printf '%*s' 1000 "")"

# --- LOAD VARS & EXTRACT COLOR ---
declare -A VARS_MAP
while IFS='=' read -r key val; do
    key="$(echo "$key" | tr -d '[:space:]')"
    val="$(echo "$val" | xargs | tr -d '"')"
    [[ -n "$key" && -n "$val" ]] && VARS_MAP["$key"]="$val"
done < "$VARS"

# Get the color variable from your Hyprland file
BIND_COLOR_RGBA="${VARS_MAP['$colMain']}" 
# Convert the RGBA (e.g., rgba(00ff99ee)) format to Pango Hex (#00ff99)
# Pango needs #RRGGBB (or #RRGGBBAA for transparency). We use a 6-digit hex for robustness.
BIND_COLOR_HEX="$(echo "$BIND_COLOR_RGBA" | sed -E 's/rgba\((\w+)\w\w\)/\1/')"
# Final Pango Color String (e.g., #00ff99)
PANGO_COLOR="#${BIND_COLOR_HEX:0:6}" 

# --- COLLECT LINES ---
mapfile -t BINDLINES < <(grep -hE '^bindd[[:space:]]*=' "$KEYDIR"/*.conf 2>/dev/null)

# --- BUILD ROFI LIST ---
bind_output=""
i=0

for line in "${BINDLINES[@]}"; do
    # 1. Parse Hyprland Syntax
    mod="$(echo "$line" | cut -d',' -f1 | sed -E 's/^bindd[[:space:]]*=[[:space:]]*//; s/[[:space:]]//g')"
    key="$(echo "$line" | cut -d',' -f2 | xargs)"
    full_desc_field="$(echo "$line" | cut -d',' -f3 | xargs)"
    raw_cmd_full="$(echo "$line" | cut -d',' -f4- | xargs)"

    # 2. Resolve Mods
    mods="${VARS_MAP[$mod]}"
    [[ -z "$mods" ]] && mods="$mod"
    bind_pretty="${mods} ${key}" 

    # 3. Split Description / Tags
    if [[ "$full_desc_field" == *"|"* ]]; then
        desc_vis="${full_desc_field%%|*}"
        metas="${full_desc_field#*|}"
    else
        desc_vis="$full_desc_field"
        metas=""
    fi
    desc_vis="$(echo "$desc_vis" | xargs)"
    metas="$(echo "$metas" | xargs)"
    
    # 4. Prepare Search Tokens (Fuzzy Search Boost)
    mod_key_boost="$(echo "$mods $key" | awk '{print $1" "$NF}' | tr '[:upper:]' '[:lower:]')"
    norm_tokens="$(echo "$mods $key $metas $raw_cmd_full $mod_key_boost" | tr '[:upper:]' '[:lower:]')"

    # 5. Alignment Padding
    bind_len=${#bind_pretty}
    pad=$(( PAD - bind_len ))
    [[ $pad -lt 1 ]] && pad=1
    spaces="$(printf '%*s' "$pad")"

    # --- THE INLINE STYLING FIX (Step 2) ---
    # Wrap the keybinding in Pango markup for color and bolding
    BINDING_STYLE="<span color='${PANGO_COLOR}'><b>${bind_pretty}</b></span>"
    
    # Construct the line: Styled Binding + Plain Description + Hidden Tokens
    output_line="${BINDING_STYLE}${spaces}${desc_vis}${INVISIBLE_SEP}${SPACER}ID:${i} ${norm_tokens}"
    bind_output+="${output_line}\n"
    
    ((i++))
done

# --- RUN ROFI (CRITICAL CHANGES) ---
# Use -dmenu, -markup-rows, and -theme
selection="$(echo -e "$bind_output" | rofi -dmenu -markup-rows -theme "$STYLE" --insensitive --prompt "Keybinds...")"
[[ -z "$selection" ]] && exit 0

# --- EXECUTE ---
{
    if [[ "$selection" =~ ID:([0-9]+) ]]; then
        line_id="${BASH_REMATCH[1]}"
        target_line="${BINDLINES[$line_id]}"

        dispatcher_arg="$(echo "$target_line" | cut -d',' -f4- | xargs)"
        
        dispatcher="${dispatcher_arg%%,*}"
        arg="${dispatcher_arg#*,}"
        arg="$(echo "$arg" | xargs)"

        # EXECUTE
        if [[ "$dispatcher" == "exec" ]]; then
            eval "$arg" & disown
        else
            hyprctl dispatch "$dispatcher" "$arg"
        fi
        
        exit 0
    else
        echo "Error: Could not find Line ID in selection."
        exit 1
    fi
}
