#!/usr/bin/env bash

# --- CONFIGURATION ---
PAD=20
KEYDIR="${HOME}/.config/hypr/keys"
VARS="${HOME}/.config/hypr/vars.conf"

# The output delimiter required by Walker to separate fields.
# We use a Tab (\t) to separate the display text from the hidden ID and tokens.
SPACER="$(printf '%*s' 1000 "")"
WALKER_DELIMITER=$'\t'

# --- LOAD VARS ---
declare -A VARS_MAP
while IFS='=' read -r key val; do
    key="$(echo "$key" | tr -d '[:space:]')"
    val="$(echo "$val" | xargs | tr -d '"')"
    [[ -n "$key" && -n "$val" ]] && VARS_MAP["$key"]="$val"
done < "$VARS"

# --- COLLECT LINES ---
mapfile -t BINDLINES < <(grep -hE '^bindd[[:space:]]*=' "$KEYDIR"/*.conf 2>/dev/null)

# --- BUILD WALKER LIST ---
bind_output=""
i=0

for line in "${BINDLINES[@]}"; do
    # 1. Parse Hyprland Syntax
    mod="$(echo "$line" | cut -d',' -f1 | sed -E 's/^bindd[[:space:]]*=[[:space:]]*//; s/[[:space:]]//g')"
    key="$(echo "$line" | cut -d',' -f2 | xargs)"
    full_desc_field="$(echo "$line" | cut -d',' -f3 | xargs)"
    raw_cmd_full="$(echo "$line" | cut -d',' -f4- | xargs)"

    # 2. Resolve Mods & Standardized Display
    mods="${VARS_MAP[$mod]}"
    [[ -z "$mods" ]] && mods="$mod"
    bind_pretty="${mods} ${key}" 

    # 3. Split Description / Tags
    if [[ "$full_desc_field" == *"|"* ]]; then
        desc_vis="${full_desc_field%%|*}"
        metas="${full_desc_field#*|}"
    else
        desc_vis="$full_desc_field"
        metas=""
    fi
    desc_vis="$(echo "$desc_vis" | xargs)"
    metas="$(echo "$metas" | xargs)"
    
    # 4. Prepare Search Tokens (Fuzzy Search Boost)
    mod_key_boost="$(echo "$mods $key" | awk '{print $1" "$NF}' | tr '[:upper:]' '[:lower:]')"
    # Tokens include the line ID, which will be extracted after selection
    norm_tokens="ID:${i} $(echo "$mods $key $metas $raw_cmd_full $mod_key_boost" | tr '[:upper:]' '[:lower:]')"

    # 5. Alignment Padding
    bind_len=${#bind_pretty}
    pad=$(( PAD - bind_len ))
    [[ $pad -lt 1 ]] && pad=1
    spaces="$(printf '%*s' "$pad")"
    
    # 6. CONSTRUCT THE LINE
    # Walker shows the first field cleanly. We use the tab to ensure the rest is treated as data.
    # We put the visible text in field 1.
    visible_text="${bind_pretty}${spaces}${desc_vis}"
    # We put the ID, Spacer, and Tokens in field 2.
    # FIELD 2 is where we hide everything using the spacer.
    hidden_search_data="${WALKER_DELIMITER}ID:${i}${SPACER}${norm_tokens}"
        
    # The final line format for Walker: FIELD 1 + FIELD 2
    output_line="${visible_text}${hidden_search_data}"
    bind_output+="${output_line}\n"

    ((i++))
done

# --- RUN WALKER (CRITICAL CHANGE) ---
# Walker runs the command on select and returns the full line by default, 
# but it will filter based on the hidden tokens.
selection="$(echo -e "$bind_output" | walker --dmenu "Keybinds...")"
[[ -z "$selection" ]] && exit 0

# --- EXECUTE ---
{
    # 1. Walker returns the *entire selected line*, so we first extract the hidden tokens (the part after the TAB)
    hidden_data="$(echo "$selection" | cut -f2 -d$'\t')"

    # 2. Extract the ID from the hidden data using Regex
    # if [[ "$hidden_data" =~ ID:([0-9]+) ]]; then
    if [[ "$selection" =~ ID:([0-9]+) ]]; then
        line_id="${BASH_REMATCH[1]}"
        target_line="${BINDLINES[$line_id]}"

        # 3. Extract Dispatcher and Arg
        dispatcher_arg="$(echo "$target_line" | cut -d',' -f4- | xargs)"
        dispatcher="${dispatcher_arg%%,*}"
        arg="${dispatcher_arg#*,}"
        arg="$(echo "$arg" | xargs)"
        
        # 4. Command Pre-Expansion (Substitute Hyprland variables like $webBrowser)
        for var_name in "${!VARS_MAP[@]}"; do
            var_value="${VARS_MAP[$var_name]}"
            arg="${arg//$var_name/$var_value}"
        done

        # 5. EXECUTE
        if [[ "$dispatcher" == "exec" ]]; then
            eval "$arg" & disown
        else
            hyprctl dispatch "$dispatcher" "$arg"
        fi
        
        exit 0
    else
        # Fallback if ID is missing (should not happen)
        echo "Error: Could not find Line ID in selection."
        exit 1
    fi
}
