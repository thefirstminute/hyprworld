#!/usr/bin/env python3
import json
import subprocess
import sys
import math

def get_hyprland_data(command):
    try:
        output = subprocess.check_output(f"hyprctl {command} -j", shell=True)
        return json.loads(output)
    except Exception as e:
        print(f"Error executing hyprctl {command}: {e}", file=sys.stderr)
        return None

def get_center(window):
    x = window['at'][0]
    y = window['at'][1]
    w = window['size'][0]
    h = window['size'][1]
    return x + w / 2, y + h / 2

def calculate_distance(p1, p2):
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 hypr_smart_focus.py <direction: l, r, u, d>")
        sys.exit(1)

    direction = sys.argv[1].lower()
    
    # Get current state
    active_window = get_hyprland_data("activewindow")
    clients = get_hyprland_data("clients")

    if not active_window or not clients:
        sys.exit(1)

    # Filter clients: must be mapped, not hidden, and on the same workspace 
    # (OR remove workspace filter if you want to jump across monitors)
    # Hyprland's native movefocus jumps monitors, so we will consider all visible windows.
    candidates = [c for c in clients if c['mapped'] and not c['hidden']]
    
    # Remove the active window from candidates
    candidates = [c for c in candidates if c['address'] != active_window['address']]

    active_cx, active_cy = get_center(active_window)
    
    best_candidate = None
    min_distance = float('inf')

    # Angle tolerances (in degrees) to prevent jumping to windows that are technically 
    # "left" but way above/below.
    # 45 degrees usually feels natural.
    
    for client in candidates:
        cx, cy = get_center(client)
        dx = cx - active_cx
        dy = cy - active_cy
        
        is_candidate = False
        
        # Check direction logic
        if direction == 'l': # Left: x decreases
            if dx < 0 and abs(dy) < abs(dx): is_candidate = True
        elif direction == 'r': # Right: x increases
            if dx > 0 and abs(dy) < abs(dx): is_candidate = True
        elif direction == 'u': # Up: y decreases
            if dy < 0 and abs(dx) < abs(dy): is_candidate = True
        elif direction == 'd': # Down: y increases
            if dy > 0 and abs(dx) < abs(dy): is_candidate = True

        if is_candidate:
            dist = calculate_distance((active_cx, active_cy), (cx, cy))
            if dist < min_distance:
                min_distance = dist
                best_candidate = client

    if best_candidate:
        addr = best_candidate['address']
        print(f"Focusing window: {best_candidate['title']} ({addr})")
        
        # 1. Focus the window
        subprocess.run(f"hyprctl dispatch focuswindow address:{addr}", shell=True)
        
        # 2. If it's floating, raise it to top (Z-order)
        if best_candidate['floating']:
            subprocess.run("hyprctl dispatch alterzorder top", shell=True)
            
    else:
        # Fallback: If our math finds nothing (sometimes happens at edges), 
        # let Hyprland try its native movefocus as a backup.
        print("No smart candidate found. Fallback to native movefocus.")
        subprocess.run(f"hyprctl dispatch movefocus {direction}", shell=True)

if __name__ == "__main__":
    main()
